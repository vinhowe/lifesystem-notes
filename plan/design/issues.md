# Issue system (or, how this whole thing might work ideally)

I'm thinking of basing it on Git--literally using Git with some modifications. It'll probably have to be roughly like GitHub--but pull requests are somehow different? I'm not sure.

We'll call them pull requests until we can think of a reason not to. What are they? A pull request is when you want to make a change to the spec. Why not just make changes in master? You can. You should be able to, I think. Just for quick things. But a pull request is when you want to:

* experiment with changes
* make a larger set of changes

The latter use-case doesn't seem like it would be really useful in the same way that it might in software development. The first one seems more useful. Maybe, though! If you want to refactor some principles to do some thing. If you want to track a set of changes and possibly keep some comments, maybe.

So, why wouldn't it work to just use GitHub? Why couldn't we just run this off of GitHub? First off, I don't really think I want it to be exactly like Git. I want it to somehow be more accessible. But I need to build something that works well for myself first and then try to adapt it to be more user friendly based on the initial feelings I get about it. As in, if I think that it's doing a really good job in whatever incarnation I have, then I should start thinking about how to adapt it to a wider audience. Which means that I have the freedom to make something as esoteric as possible.

And here's the other thing. Of course this is a personal tool and so it has to be really useful, but you want to strike a balance with making it something that can fail quickly. If it takes too long to develop and then its big thesis is invalid, then it fails slower and the net time spent is lower. So I want something that I can feel confident about making a conclusion about but that isn't such an investment that I'm set back too far.

Without getting mired in the technical analogies, let's try to hone in on the core theses of this issue system. The idea is that you identify problems in your life and experiment with analysis and small changes made over time to fix them. That's basically it. The trick is in saving those changes or keeping up with all of the rules that I've made for myself. And what if two issues end up running an experiment on the same thing? That's where the Git idea comes in, and its merging model starts to seem really appealling. But let's think about these experiments and what they actually do.

An experiment is a commitment from a start date to an end date to start, change, or stop something. It's a way to see what works for me. An example might be a morning routine. When I make a morning routine and put it down on paper, I can't possibly see my state of mind when I get up in the morning. And when I get up in the morning, I don't want to do the morning routine that I wrote down. It's this disparity between my planning self and doing self that experiments try to address. Because whenever I don't do something, there's a reason of some sort. What I do during the period of the experiment is capture all of these reasons while still doing my best to follow through with the committment. The reason that this following through is useful is because some changes need some time to work. A time-bound experiment might have me try to go to bed at a certain time and get up at a certain time. This might be difficult because I would feel really tired when trying to adjust to the new routine, which is why I'd have to go until the end of the experiment to try it out.

There's another thing. What about experiments that have changes specific to the experiments themselves? Using the above example, say that I wanted to start getting up at 7 instead of 9 but that I wanted to do it gradually over a few days. In the experiment, I'd specify that I wanted to make the changes gradually. What would the acceptance criteria for an experiment like that look like? The thing about an experiment is that it's supposed to validate some change. A change that wasn't there before and is there now. It's basically a time-bound pull request where you're your own reviewer. That's what it is. Feedback! You make a PR for your personal spec, then you get feedback on the PR by doing experiments. Those experiments prompt more changes, which prompt more experiments. You merge whenever you're ready. What an experiment really does is saves the head of the PR to review so that if the PR is updated, the experiment will remain the same. It seems to me like the simplest way to add meta instructions to experiments would be to add an optional field of some sort. Like "strategy" or something--but I don't want it to be so specific that it's stifling. One thing that does seem like it would be a good idea is having an acceptance criteria field on reviews--at least optionally.

A lot of this seems like it would just kind of fall into place if I could figure out how to build it organically. I'm trying to foresee any big gotchas, and I'll miss a few if experience is any indicator.

I wonder how hard it would be to just build this experimentation functionality into a GitHub bot. It seems like it would be less work. Maybe. The problem is that I still want to be able to use my own proprietary format for the files themselves. As in, I don't want to create a directory structure. I want to basically create objects that reference other objects. The problem with this is that it's really hard to diff with Git if everything is encrypted. So maybe what I could do is encrypt the entire repo and decrypt it every time? This hardly seems optimal either.

Yet another thing is that we don't want to do diffs on the catalog. It should be able to keep up for the most part.
